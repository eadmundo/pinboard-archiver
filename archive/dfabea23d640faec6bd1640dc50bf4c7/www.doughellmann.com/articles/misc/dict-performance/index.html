
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>The Performance Impact of Using dict() Instead of {} in CPython 2.7 - Doug Hellmann</title>

<link rel="stylesheet" href="../../../_static/default.css" 
    type="text/css" />
<style>
    body {
        margin: 8px;
    }
    .highlight {
        background-color: white;
        border: 0;
    }
    .highlight pre {
        background-color: white;
    }
</style>

<link href="../../../_static/css/leaves.css" rel="stylesheet" type="text/css" />
<link rel="alternate" type="application/atom+xml"
      title="Doug Hellmann"
      href="http://feeds.feedburner.com/DougHellmann" />
<link rel="alternate" type="application/atom+xml"
      title="Doug Hellmann Project Releases"
      href="http://feeds.feedburner.com/DougHellmann-Releases" />
<link rel="alternate" type="application/atom+xml"
      title="Doug Hellmann Links"
      href="http://feeds.feedburner.com/DougHellmannLinkBlog" />



<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    '../../../',
      VERSION:     '',
      COLLAPSE_MODINDEX: false,
      FILE_SUFFIX: '.html'
  };
</script>

<script type="text/javascript" src="../../../_static/jquery.js"></script>
<script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="up" title="Miscellaneous Articles" href="http://www.doughellmann.com/articles/misc/index.html" />

<meta name="verify-v1" content="5saTcOa2HLac4V85yUg3SARfun1PqT5Upu7IR/6fpv4="/>
</head>
<body>
    
<div id="container">
    
<div id="header">
  <a href="http://www.doughellmann.com/index.html"><h1>Doug Hellmann</h1></a>
  <p></p>
</div>

<div id="sidebar_left_wrapper">

<div id="navigation"> 
	<ul id="navlist">
		<li><a href="http://www.doughellmann.com/index.html">Home</a></li>
		<li><a href="http://www.doughellmann.com/PyMOTW/">PyMOTW</a></li>
		<li><a href="http://blog.doughellmann.com/" target="_">Blog</a></li>
		<li><a href="http://www.doughellmann.com/articles/index.html">Articles</a></li>
		<li><a href="http://www.doughellmann.com/books/index.html">Books</a></li>
		<li><a href="http://www.doughellmann.com/projects/index.html">Projects</a></li>
		<li><a href="http://code.doughellmann.com/" target="_">Code</a></li>
		<li><a href="http://www.doughellmann.com/about/index.html">About</a></li>
		<li><a href="http://www.doughellmann.com/genindex.html">Site Index</a></li>
	</ul>
</div>



</div>


<div id="sidebar">
  <ul>
<li><a class="reference internal" href="index.html#">The Performance Impact of Using dict() Instead of {} in CPython 2.7</a><ul>
<li><a class="reference internal" href="index.html#tl-dr">tl;dr</a></li>
<li><a class="reference internal" href="index.html#initial-hypothesis">Initial Hypothesis</a></li>
<li><a class="reference internal" href="index.html#measuring-performance">Measuring Performance</a></li>
<li><a class="reference internal" href="index.html#what-is-going-on">What is going on?</a></li>
<li><a class="reference internal" href="index.html#examining-more-complex-examples">Examining More Complex Examples</a></li>
<li><a class="reference internal" href="index.html#interpreter-source">Interpreter Source</a></li>
<li><a class="reference internal" href="index.html#what-happens-when-you-call-dict">What Happens When You Call dict()?</a></li>
<li><a class="reference internal" href="index.html#creating-a-dictionary-with">Creating a Dictionary with {}</a></li>
<li><a class="reference internal" href="index.html#extreme-tests">Extreme Tests</a></li>
<li><a class="reference internal" href="index.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>

<p/><p><iframe src="../../../../rcm.amazon.com/e/cm%3Flt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=DDDDDD&amp;fc1=000000&amp;lc1=CC6714&amp;t=hellflynet-20&amp;o=1&amp;p=8&amp;l=as1&amp;m=amazon&amp;f=ifr&amp;md=10FE9736YVPPT7A0FBG2&amp;asins=0321767349.html" style="width:120px;height:240px;margin:0 1em 0 1em;" scrolling="no" frameborder="0"></iframe></p>
    <p class="ads">
    <script type="text/javascript"><!--
    google_ad_client = "pub-3205160560229413";
    google_ad_width = 120;
    google_ad_height = 600;
    google_ad_format = "120x600_as";
    google_ad_type = "text";
    //2007-10-27: www.doughellmann.com
    google_ad_channel = "0828653884";
    google_color_border = "FFFFFF";
    google_color_bg = "FFFFFF";
    google_color_link = "CC6714";
    google_color_text = "000000";
    google_color_url = "999999";
    google_ui_features = "rc:0";
    //-->
    </script>
    <script type="text/javascript"
      src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
    </script>
    </p>
</div>

	  
<div id="content">

    <div class="related">
      <h3>Navigation</h3>
      <ul>
          <li><a href="http://www.doughellmann.com/articles/index.html" >Articles</a> &raquo;</li>
          <li><a href="http://www.doughellmann.com/articles/misc/index.html" accesskey="U">Miscellaneous Articles</a> &raquo;</li> 
      </ul>
    </div>

  <div class="section" id="the-performance-impact-of-using-dict-instead-of-in-cpython-2-7">
<span id="article-misc-dict-performance"></span><h1>The Performance Impact of Using dict() Instead of {} in CPython 2.7<a class="headerlink" href="index.html#the-performance-impact-of-using-dict-instead-of-in-cpython-2-7" title="Permalink to this headline">¶</a></h1>
<p class="pub-date">12 Nov 2012</p>
<p class="deck">I&#8217;ve been reviewing lot of code lately for various open source and
internal projects written in Python. As part of those reviews, I
have noticed what I think is a trend toward using <tt class="docutils literal"><span class="pre">dict()</span></tt>
instead of <tt class="docutils literal"><span class="pre">{}</span></tt> to create dictionaries. I don&#8217;t know exactly why
this trend has emerged. Perhaps the authors perceive <tt class="docutils literal"><span class="pre">dict()</span></tt> as
more readable than <tt class="docutils literal"><span class="pre">{}</span></tt>.  Whatever the reason, my intuition told
me calling the function version of the constructor for a dictionary
would impose a performance penalty. I studied what happens in both
cases to understand how significant that penalty is, and the
results confirmed my intuition.</p>
<div class="section" id="tl-dr">
<h2>tl;dr<a class="headerlink" href="index.html#tl-dr" title="Permalink to this headline">¶</a></h2>
<p>With CPython 2.7, using <tt class="docutils literal"><span class="pre">dict()</span></tt> to create dictionaries takes up to
6 times longer and involves more memory allocation operations than the
literal syntax.  Use <tt class="docutils literal"><span class="pre">{}</span></tt> to create dictionaries, especially if you
are pre-populating them, unless the literal syntax does not work for
your case.</p>
</div>
<div class="section" id="initial-hypothesis">
<h2>Initial Hypothesis<a class="headerlink" href="index.html#initial-hypothesis" title="Permalink to this headline">¶</a></h2>
<p>I wanted to study the performance difference between the literal
syntax for creating a dictionary instance (<tt class="docutils literal"><span class="pre">{}</span></tt>) and using the name
of the class to create one (<tt class="docutils literal"><span class="pre">dict()</span></tt>).  I knew that the Python
interpreter is based on opcodes and that there are codes dedicated to
creating a dictionary that would not be invoked when the <tt class="docutils literal"><span class="pre">dict()</span></tt>
form was used instead of the literal form. I suspected that the extra
overhead for looking up the name <tt class="docutils literal"><span class="pre">&quot;dict&quot;</span></tt> and then calling the
function would make the &#8220;function&#8221; form slower.</p>
</div>
<div class="section" id="measuring-performance">
<h2>Measuring Performance<a class="headerlink" href="index.html#measuring-performance" title="Permalink to this headline">¶</a></h2>
<p>I began my analysis by applying <a class="reference external" href="http://www.doughellmann.com/PyMOTW/timeit/">timeit</a> to see if the
performance difference was even measurable.</p>
<div class="highlight-python"><pre>$ python2.7 -m timeit -n 1000000 -r 5 -v 'dict()'
raw times: 0.24 0.24 0.24 0.239 0.24
1000000 loops, best of 5: 0.239 usec per loop

$ python2.7 -m timeit -n 1000000 -r 5 -v '{}'
raw times: 0.0417 0.0413 0.0407 0.0411 0.042
1000000 loops, best of 5: 0.0407 usec per loop</pre>
</div>
<p>Immediately I could see that not only was there a difference, it was
even more significant than I expected. Using <tt class="docutils literal"><span class="pre">dict()</span></tt> to create an
empty dictionary took 6 times longer than using the literal
syntax. Would the difference be the same if the dictionary had
members?</p>
<p class="callout">Using dict() to create an empty dictionary took 6 times longer
than using the literal syntax.</p>
<div class="highlight-python"><pre>$ python2.7 -m timeit -n 1000000 -r 5 -v 'dict(a="A", b="B", c="C")'
raw times: 0.56 0.548 0.563 0.563 0.556
1000000 loops, best of 5: 0.548 usec per loop

$ python2.7 -m timeit -n 1000000 -r 5 -v '{"a": "A", "b": "B", "c": "C"}'
raw times: 0.178 0.178 0.18 0.177 0.179
1000000 loops, best of 5: 0.177 usec per loop</pre>
</div>
<p>Passing a few members to the dictionary brought the difference closer
together, but the function form was still taking three times as long.</p>
</div>
<div class="section" id="what-is-going-on">
<h2>What is going on?<a class="headerlink" href="index.html#what-is-going-on" title="Permalink to this headline">¶</a></h2>
<p>After establishing the performance difference, I asked myself what was
going on to cause such a significant slowdown. To answer that
question, I needed to look more deeply into what the interpreter was
doing as it processed each expression. I wanted to see which (and how
many) opcodes were being executed. I used <a class="reference external" href="http://www.doughellmann.com/PyMOTW/dis/">dis</a> to
<em>disassemble</em> the Python expressions to see which opcodes implement
each.</p>
<p>To use dis from the command line, I needed input files containing the
different expressions I was studying. I created <tt class="docutils literal"><span class="pre">func.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">()</span>
</pre></div>
</div>
<p>and <tt class="docutils literal"><span class="pre">literal.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{}</span>
</pre></div>
</div>
<p>The output of dis is arranged in columns with the original source line
number, the instruction “address” within the code object, the opcode
name, and any arguments passed to the opcode.</p>
<div class="highlight-python"><pre>$ python2.7 -m dis func.py
  1           0 LOAD_NAME                0 (dict)
              3 CALL_FUNCTION            0
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE</pre>
</div>
<p>The function form uses two separate opcodes: <tt class="docutils literal"><span class="pre">LOAD_NAME</span></tt> to find the
object associated with the name &#8220;dict&#8221;, and <tt class="docutils literal"><span class="pre">CALL_FUNCTION</span></tt> to
invoke it. The last three opcodes are not involved in creating or
populating the dictionary, and appear in both versions of the code, so
I ignored them for my analysis.</p>
<p>The literal form uses a special opcode to create the dictionary:</p>
<div class="highlight-python"><pre>$ python2.7 -m dis literal.py
  1           0 BUILD_MAP                0
              3 POP_TOP
              4 LOAD_CONST               0 (None)
              7 RETURN_VALUE</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">BUILD_MAP</span></tt> opcode creates a new empty dictionary instance and
places it on the top of the interpreter&#8217;s stack.</p>
<p>After comparing the two sets of opcodes, I suspected that the
<tt class="docutils literal"><span class="pre">CALL_FUNCTION</span></tt> operation was the culprit, since calling functions
is relatively expensive in Python. However, these were trivial
examples and did not look like what I was seeing in code reviews. Most
of the actual code I had seen was populating the dictionary as it
created it, and I wanted to understand what difference that would
make.</p>
</div>
<div class="section" id="examining-more-complex-examples">
<h2>Examining More Complex Examples<a class="headerlink" href="index.html#examining-more-complex-examples" title="Permalink to this headline">¶</a></h2>
<p>I created two new source files that set three key/value pairs in the
dictionary as it is created. I started with <tt class="docutils literal"><span class="pre">func-members.py</span></tt>, which
instantiated a dictionary with the same members using the <tt class="docutils literal"><span class="pre">dict()</span></tt>
function.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">,</span>
     <span class="n">b</span><span class="o">=</span><span class="s">&quot;B&quot;</span><span class="p">,</span>
     <span class="n">c</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">,</span>
     <span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p class="callout">I realized that in order to really understand what was going on, I
would have to look at the interpreter implementation.</p>
<p>The disassembled version of <tt class="docutils literal"><span class="pre">func-members.py</span></tt> started the same way
as the earlier example, looking for the <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> function:</p>
<div class="highlight-python"><pre>$ python2.7 -m dis func-members.py
  1           0 LOAD_NAME                0 (dict)</pre>
</div>
<p>Then it showed key/value pairs being pushed onto the stack using
<tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt> to create named arguments for the function.</p>
<div class="highlight-python"><pre>            3 LOAD_CONST               0 ('a')
            6 LOAD_CONST               1 ('A')
            9 LOAD_CONST               2 ('b')

2          12 LOAD_CONST               3 ('B')
           15 LOAD_CONST               4 ('c')

3          18 LOAD_CONST               5 ('C')</pre>
</div>
<p>Finally <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> was called:</p>
<div class="highlight-python"><pre>21 CALL_FUNCTION          768
24 POP_TOP
25 LOAD_CONST               6 (None)
28 RETURN_VALUE</pre>
</div>
<p>Next I created <tt class="docutils literal"><span class="pre">literal-members.py</span></tt>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="s">&quot;A&quot;</span><span class="p">,</span>
 <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="s">&quot;B&quot;</span><span class="p">,</span>
 <span class="s">&quot;c&quot;</span><span class="p">:</span> <span class="s">&quot;C&quot;</span><span class="p">,</span>
 <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The disassembled version of this example showed a few differences from
the literal example without any values. First, the argument to
<tt class="docutils literal"><span class="pre">BUILD_MAP</span></tt> was 3 instead of 0, indicating that there were three
key/value pairs on the stack to go into the dictionary.</p>
<div class="highlight-python"><pre>$ python2.7 -m dis literal-members.py
  1           0 BUILD_MAP                3</pre>
</div>
<p>It also showed the values and then keys being pushed onto the stack
using <tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt>.</p>
<div class="highlight-python"><pre>3 LOAD_CONST               0 ('A')
6 LOAD_CONST               1 ('a')</pre>
</div>
<p>Finally, a new opcode, <tt class="docutils literal"><span class="pre">STORE_MAP</span></tt>, appeared once after each
key/value pair is processed.</p>
<div class="highlight-python"><pre>9 STORE_MAP</pre>
</div>
<p>The same pattern repeated for each of the other two key/value pairs.</p>
<div class="highlight-python"><pre>2          10 LOAD_CONST               2 ('B')
           13 LOAD_CONST               3 ('b')
           16 STORE_MAP

3          17 LOAD_CONST               4 ('C')
           20 LOAD_CONST               5 ('c')
           23 STORE_MAP
           24 POP_TOP
           25 LOAD_CONST               6 (None)
           28 RETURN_VALUE</pre>
</div>
<p>After looking at the output more closely, I noticed that there were
actually <em>fewer</em> opcodes in the function form than the literal
form. There were no <tt class="docutils literal"><span class="pre">STORE_MAP</span></tt> opcodes, just the <tt class="docutils literal"><span class="pre">CALL_FUNCTION</span></tt>
after all of the items were on the stack. At this point I realized
that in order to really understand what was going on, I would have to
look at the interpreter implementation.</p>
</div>
<div class="section" id="interpreter-source">
<h2>Interpreter Source<a class="headerlink" href="index.html#interpreter-source" title="Permalink to this headline">¶</a></h2>
<p>Up to now, I had been examining the behavior of the interpreter by
feeding it inputs and seeing what it did with them. To examine it at a
deeper level, I had to download the source following the instructions
in the <a class="reference external" href="http://docs.python.org/devguide/">Dev Guide</a>.</p>
<div class="highlight-python"><pre>$ hg clone http://hg.python.org/cpython
destination directory: cpython
requesting all changes
adding changesets
adding manifests
adding file changes
added 80406 changesets with 178013 changes to 9805 files (+2 heads)
updating to branch default
3750 files updated, 0 files merged, 0 files removed, 0 files unresolved

$ cd cpython</pre>
</div>
<p>And, since I am looking at Python 2.7 rather than 3.3:</p>
<div class="highlight-python"><pre>$ hg update 2.7
3768 files updated, 0 files merged, 810 files removed, 0 files unresolved</pre>
</div>
<p>The interpreter evaluates opcodes in a loop defined in
<tt class="xref py py-func docutils literal"><span class="pre">PyEval_EvalFrameEx()</span></tt> in <a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Python/ceval.c">Python/ceval.c</a>. Each opcode name
corresponds to an entry in the <tt class="docutils literal"><span class="pre">switch</span></tt> statement. For example, the
<tt class="docutils literal"><span class="pre">POP_TOP</span></tt> opcode that appears near the end of each disassembled
example is implemented as:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">POP_TOP</span>:
            <span class="n">v</span> <span class="o">=</span> <span class="n">POP</span><span class="p">();</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The top-most item is removed from the stack and its reference count is
decremented to allow it (eventually) to be garbage collected. After
orienting myself in the source, I was ready to trace through the
opcodes used in the examples above.</p>
</div>
<div class="section" id="what-happens-when-you-call-dict">
<h2>What Happens When You Call dict()?<a class="headerlink" href="index.html#what-happens-when-you-call-dict" title="Permalink to this headline">¶</a></h2>
<p>The disassembly above shows that the opcodes used to call <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt>
to create a dictionary are <tt class="docutils literal"><span class="pre">LOAD_NAME</span></tt>, <tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt>, and
<tt class="docutils literal"><span class="pre">CALL_FUNCTION</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">LOAD_NAME</span></tt> opcode finds the object associated with the given
name (&#8220;dict&#8221; in this case) and puts it on top of the stack.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">LOAD_NAME</span>:
            <span class="n">w</span> <span class="o">=</span> <span class="n">GETITEM</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_locals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_SystemError</span><span class="p">,</span>
                             <span class="s">&quot;no locals when loading %s&quot;</span><span class="p">,</span>
                             <span class="n">PyObject_REPR</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>
                <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_EXCEPTION</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_CheckExact</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyObject_GetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyErr_ExceptionMatches</span><span class="p">(</span>
                                    <span class="n">PyExc_KeyError</span><span class="p">))</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="n">PyErr_Clear</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_globals</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_builtins</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">format_exc_check_arg</span><span class="p">(</span>
                                    <span class="n">PyExc_NameError</span><span class="p">,</span>
                                    <span class="n">NAME_ERROR_MSG</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Three separate namespaces (represented as dictionaries) are
searched. First, the local namespace from inside any function scope,
followed by the module global namespace, and then the set of built-ins.</p>
<p><tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt> is the next opcode used. It pushes literal constant
values onto the interpreter&#8217;s stack:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">LOAD_CONST</span>:
            <span class="n">x</span> <span class="o">=</span> <span class="n">GETITEM</span><span class="p">(</span><span class="n">consts</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">oparg</span></tt> value indicates which constant to take out of the set of
constants found in the code object. The constant&#8217;s reference count is
increased and then it is pushed onto the top of the stack. This is an
inexpensive operation since no name lookup is needed.</p>
<p>The portion of the implementation of <tt class="docutils literal"><span class="pre">CALL_FUNCTION</span></tt> in the case
statement looks similarly simple:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">CALL_FUNCTION</span>:
        <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">**</span><span class="n">sp</span><span class="p">;</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_ALL</span><span class="p">);</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">stack_pointer</span><span class="p">;</span>
<span class="cp">#ifdef WITH_TSC</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="n">oparg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intr0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intr1</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="n">stack_pointer</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The function is called and its return value is pushed onto the
stack. (The <tt class="docutils literal"><span class="pre">WITH_TSC</span></tt> conditional compilation instruction controls
whether the Pentium timestamp counter is used, and can be ignored for
this general analysis.)</p>
<p>The implementation of <tt class="xref py py-func docutils literal"><span class="pre">call_function()</span></tt> starts to expose some of
the complexity of calling Python functions.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">call_function</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oparg</span>
<span class="cp">#ifdef WITH_TSC</span>
                <span class="p">,</span> <span class="n">uint64</span><span class="o">*</span> <span class="n">pintr0</span><span class="p">,</span> <span class="n">uint64</span><span class="o">*</span> <span class="n">pintr1</span>
<span class="cp">#endif</span>
                <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">na</span> <span class="o">=</span> <span class="n">oparg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nk</span> <span class="o">=</span> <span class="p">(</span><span class="n">oparg</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nk</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">pfunc</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="o">*</span><span class="n">pfunc</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="cm">/* Always dispatch PyCFunction first, because these are</span>
<span class="cm">       presumed to be the most frequent callable object.</span>
<span class="cm">    */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyCFunction_Check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">PyCFunction_GET_FLAGS</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">PyThreadState_GET</span><span class="p">();</span>

        <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_CFUNCTION</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">METH_NOARGS</span> <span class="o">|</span> <span class="n">METH_O</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">PyCFunction</span> <span class="n">meth</span> <span class="o">=</span> <span class="n">PyCFunction_GET_FUNCTION</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">PyCFunction_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">METH_NOARGS</span> <span class="o">&amp;&amp;</span> <span class="n">na</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">meth</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span><span class="nb">NULL</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">METH_O</span> <span class="o">&amp;&amp;</span> <span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
                <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">meth</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span><span class="n">arg</span><span class="p">));</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">err_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">na</span><span class="p">);</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">callargs</span><span class="p">;</span>
            <span class="n">callargs</span> <span class="o">=</span> <span class="n">load_args</span><span class="p">(</span><span class="n">pp_stack</span><span class="p">,</span> <span class="n">na</span><span class="p">);</span>
            <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr0</span><span class="p">);</span>
            <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PyCFunction_Call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">callargs</span><span class="p">,</span><span class="nb">NULL</span><span class="p">));</span>
            <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr1</span><span class="p">);</span>
            <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">callargs</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyMethod_Check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PyMethod_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* optimize access to bound methods */</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">PyMethod_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_METHOD</span><span class="p">);</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_BOUND_METHOD</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">PyMethod_GET_FUNCTION</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="o">*</span><span class="n">pfunc</span><span class="p">);</span>
            <span class="o">*</span><span class="n">pfunc</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
            <span class="n">na</span><span class="o">++</span><span class="p">;</span>
            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyFunction_Check</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">fast_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">pp_stack</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nk</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">do_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">pp_stack</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nk</span><span class="p">);</span>
        <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr1</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Clear the stack of the function object.  Also removes</span>
<span class="cm">       the arguments in case they weren&#39;t consumed already</span>
<span class="cm">       (fast_function() and err_args() leave them on the stack).</span>
<span class="cm">     */</span>
    <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pfunc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
        <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_POP</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The number arguments the function is passed is given in <tt class="docutils literal"><span class="pre">oparg</span></tt>. The
low-end byte is the number of positional arguments, and the high-end
byte is the number of keyword arguments (lines 8-9). The value 768 in
the example above translates to 3 keyword arguments and 0 positional
arguments.</p>
<div class="highlight-python"><pre>21 CALL_FUNCTION          768</pre>
</div>
<p>There are separate cases for built-in functions implemented in C,
function written in Python, and methods of objects. All of the cases
eventually use <tt class="xref py py-func docutils literal"><span class="pre">load_args()</span></tt> to pull the positional arguments off
of the stack as a tuple:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">load_args</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">na</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_New</span><span class="p">(</span><span class="n">na</span><span class="p">);</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">na</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">PyTuple_SET_ITEM</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>And then <tt class="xref py py-func docutils literal"><span class="pre">update_keyword_args()</span></tt> is used to pull keyword arguments
off of the stack <em>as a dictionary</em>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">update_keyword_args</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">orig_kwdict</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nk</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwdict</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">orig_kwdict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">kwdict</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">kwdict</span> <span class="o">=</span> <span class="n">PyDict_Copy</span><span class="p">(</span><span class="n">orig_kwdict</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">orig_kwdict</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kwdict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">nk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">kwdict</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                         <span class="s">&quot;%.200s%s got multiple values &quot;</span>
                         <span class="s">&quot;for keyword argument &#39;%.200s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyEval_GetFuncName</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                         <span class="n">PyEval_GetFuncDesc</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                         <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">kwdict</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">kwdict</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">kwdict</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">kwdict</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>That&#8217;s right.</p>
<p class="callout">In order to pass keyword arguments to dict() to instantiate a
dictionary, first another dictionary is created.</p>
<p>After the arguments are prepared, they are passed to <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt>.
The implementation of the dictionary object is found in
<a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Objects/dictobject.c">Objects/dictobject.c</a>, and the <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt> type is defined as:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">PyTypeObject</span> <span class="n">PyDict_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;dict&quot;</span><span class="p">,</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyDictObject</span><span class="p">),</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">dict_dealloc</span><span class="p">,</span>                   <span class="cm">/* tp_dealloc */</span>
    <span class="p">(</span><span class="n">printfunc</span><span class="p">)</span><span class="n">dict_print</span><span class="p">,</span>                      <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattr */</span>
    <span class="p">(</span><span class="n">cmpfunc</span><span class="p">)</span><span class="n">dict_compare</span><span class="p">,</span>                      <span class="cm">/* tp_compare */</span>
    <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">dict_repr</span><span class="p">,</span>                        <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_number */</span>
    <span class="o">&amp;</span><span class="n">dict_as_sequence</span><span class="p">,</span>                          <span class="cm">/* tp_as_sequence */</span>
    <span class="o">&amp;</span><span class="n">dict_as_mapping</span><span class="p">,</span>                           <span class="cm">/* tp_as_mapping */</span>
    <span class="p">(</span><span class="n">hashfunc</span><span class="p">)</span><span class="n">PyObject_HashNotImplemented</span><span class="p">,</span>      <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_str */</span>
    <span class="n">PyObject_GenericGetAttr</span><span class="p">,</span>                    <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_DICT_SUBCLASS</span><span class="p">,</span>         <span class="cm">/* tp_flags */</span>
    <span class="n">dictionary_doc</span><span class="p">,</span>                             <span class="cm">/* tp_doc */</span>
    <span class="n">dict_traverse</span><span class="p">,</span>                              <span class="cm">/* tp_traverse */</span>
    <span class="n">dict_tp_clear</span><span class="p">,</span>                              <span class="cm">/* tp_clear */</span>
    <span class="n">dict_richcompare</span><span class="p">,</span>                           <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_weaklistoffset */</span>
    <span class="p">(</span><span class="n">getiterfunc</span><span class="p">)</span><span class="n">dict_iter</span><span class="p">,</span>                     <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_iternext */</span>
    <span class="n">mapp_methods</span><span class="p">,</span>                               <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dictoffset */</span>
    <span class="n">dict_init</span><span class="p">,</span>                                  <span class="cm">/* tp_init */</span>
    <span class="n">PyType_GenericAlloc</span><span class="p">,</span>                        <span class="cm">/* tp_alloc */</span>
    <span class="n">dict_new</span><span class="p">,</span>                                   <span class="cm">/* tp_new */</span>
    <span class="n">PyObject_GC_Del</span><span class="p">,</span>                            <span class="cm">/* tp_free */</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Because <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt> is a class, <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> creates a new object and
then invokes the <tt class="xref py py-func docutils literal"><span class="pre">__init__()</span></tt> method. The initialization for
<tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt> is handled by <tt class="xref py py-func docutils literal"><span class="pre">dict_init()</span></tt>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dict_update_common</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;dict&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Which calls <tt class="xref py py-func docutils literal"><span class="pre">dict_update_common()</span></tt> to update the contents of the
dictionary with the arguments passed to the initialization function.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_update_common</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">methname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyObject_HasAttrString</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;keys&quot;</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_Merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_MergeFromSeq2</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">kwds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_Merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In this case, a set of keyword arguments are passed so the very last
case is triggered and <tt class="xref py py-func docutils literal"><span class="pre">PyDict_Merge()</span></tt> is used to copy the keyword
arguments into the dictionary. There are a couple of cases for
merging, but from what I can tell because there are two dictionaries
involved the first case applies. The target dictionary is resized to
be big enough to hold the new values, and then the items from the
merging dictionary are copied in one at a time.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span>
<span class="nf">PyDict_Merge</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">override</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">PyDictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

    <span class="cm">/* We accept for the argument either a concrete dictionary object,</span>
<span class="cm">     * or an abstract &quot;mapping&quot; object.  For the former, we can do</span>
<span class="cm">     * things quite efficiently.  For the latter, we only require that</span>
<span class="cm">     * PyMapping_Keys() and PyObject_GetItem() be supported.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">==</span> <span class="n">mp</span> <span class="o">||</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="cm">/* a.update(a) or a.update({}); nothing to do */</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="cm">/* Since the target dict is empty, PyDict_GetItem()</span>
<span class="cm">             * always returns NULL.  Setting override to 1</span>
<span class="cm">             * skips the unnecessary test.</span>
<span class="cm">             */</span>
            <span class="n">override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="cm">/* Do one big resize at the start, rather than</span>
<span class="cm">         * incrementally resizing as we insert new items.  Expect</span>
<span class="cm">         * that there will be no (or few) overlapping keys.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_fill</span> <span class="o">+</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_mask</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">dictresize</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">+</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
               <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">override</span> <span class="o">||</span>
                 <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">);</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">insertdict</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">,</span>
                               <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_hash</span><span class="p">,</span>
                               <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Do it the generic, slower way */</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="n">PyMapping_Keys</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">keys</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="cm">/* Docstring says this is equivalent to E.keys() so</span>
<span class="cm">             * if E doesn&#39;t have a .keys() method we want</span>
<span class="cm">             * AttributeError to percolate up.  Might as well</span>
<span class="cm">             * do the same for any other error.</span>
<span class="cm">             */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">iter</span> <span class="o">=</span> <span class="n">PyObject_GetIter</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">PyIter_Next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span> <span class="n">key</span><span class="p">;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">PyIter_Next</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">override</span> <span class="o">&amp;&amp;</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">PyObject_GetItem</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span>
            <span class="cm">/* Iterator completed, via error */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="creating-a-dictionary-with">
<h2>Creating a Dictionary with {}<a class="headerlink" href="index.html#creating-a-dictionary-with" title="Permalink to this headline">¶</a></h2>
<p>The opcodes used to implement the literal examples are <tt class="docutils literal"><span class="pre">BUILD_MAP</span></tt>,
<tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt>, and <tt class="docutils literal"><span class="pre">STORE_MAP</span></tt>. I started with the first opcode,
<tt class="docutils literal"><span class="pre">BUILD_MAP</span></tt>, which creates the dictionary instance:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">BUILD_MAP</span>:
            <span class="n">x</span> <span class="o">=</span> <span class="n">_PyDict_NewPresized</span><span class="p">((</span><span class="n">Py_ssize_t</span><span class="p">)</span><span class="n">oparg</span><span class="p">);</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The dictionary is created using <tt class="xref py py-func docutils literal"><span class="pre">_PyDict_NewPresized()</span></tt>, from
<a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Objects/dictobject.c">Objects/dictobject.c</a>.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Create a new dictionary pre-sized to hold an estimated number of elements.</span>
<span class="cm">   Underestimates are okay because the dictionary will resize as necessary.</span>
<span class="cm">   Overestimates just mean the dictionary will be more sparse than usual.</span>
<span class="cm">*/</span>

<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyDict_NewPresized</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">minused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">minused</span><span class="o">&gt;</span><span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">dictresize</span><span class="p">((</span><span class="n">PyDictObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">,</span> <span class="n">minused</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The argument for <tt class="docutils literal"><span class="pre">BUILD_MAP</span></tt> is the number of items that are going
to be added to the new dictionary as it is created. The disassembly
for <tt class="docutils literal"><span class="pre">literal-members.py</span></tt> showed that value as <tt class="docutils literal"><span class="pre">3</span></tt> earlier.</p>
<div class="highlight-python"><pre>$ python2.7 -m dis literal-members.py
  1           0 BUILD_MAP                3</pre>
</div>
<p>Specifying the initial number of items in the dictionary is an
optimization for managing memory, since it means the table size can be
set ahead of time and it does not need to be reallocated in some
cases.</p>
<p class="callout">The argument for BUILD_MAP is the number of items that are
going to be added to the new dictionary as it is created.</p>
<p>Each key/value pair is added to the dictionary using three
opcodes. Two instances of <tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt> push the value, then the key,
onto the stack. Then a <tt class="docutils literal"><span class="pre">STORE_MAP</span></tt> opcode adds the pair to the
dictionary.</p>
<div class="highlight-python"><pre>2          10 LOAD_CONST               2 ('B')
           13 LOAD_CONST               3 ('b')
           16 STORE_MAP</pre>
</div>
<p>As we saw early, <tt class="docutils literal"><span class="pre">LOAD_CONST</span></tt> is fairly straightforward and
economical. <tt class="docutils literal"><span class="pre">STORE_MAP</span></tt> looks for the key, value, and dictionary on
the stack and calls <tt class="xref py py-func docutils literal"><span class="pre">PyDict_SetItem()</span></tt> to add the new key/value
pair. The <tt class="docutils literal"><span class="pre">STACKADJ(-2)</span></tt> line removes the key and value off from the
stack.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">STORE_MAP</span>:
            <span class="n">w</span> <span class="o">=</span> <span class="n">TOP</span><span class="p">();</span>     <span class="cm">/* key */</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">SECOND</span><span class="p">();</span>  <span class="cm">/* value */</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">THIRD</span><span class="p">();</span>   <span class="cm">/* dict */</span>
            <span class="n">STACKADJ</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">assert</span> <span class="p">(</span><span class="n">PyDict_CheckExact</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>  <span class="cm">/* v[w] = u */</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><tt class="xref py py-func docutils literal"><span class="pre">PyDict_SetItem()</span></tt> is the same function invoked when a program
uses <tt class="docutils literal"><span class="pre">d[k]</span> <span class="pre">=</span> <span class="pre">v</span></tt> to associate the value <tt class="docutils literal"><span class="pre">v</span></tt> with a key <tt class="docutils literal"><span class="pre">k</span></tt> in a
dictionary.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span>
<span class="nf">PyDict_SetItem</span><span class="p">(</span><span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyString_CheckExact</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">PyStringObject</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_shash</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">hash</span> <span class="o">=</span> <span class="n">PyObject_Hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="n">PyObject_Hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dict_set_item_by_hash_or_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The functions it calls handle resizing the internal data structure
used by the dictionary, if that&#8217;s necessary.</p>
</div>
<div class="section" id="extreme-tests">
<h2>Extreme Tests<a class="headerlink" href="index.html#extreme-tests" title="Permalink to this headline">¶</a></h2>
<p>I now had an answer explaining why the literal syntax was so much more
efficient than using the name to instantiate a dictionary. I had
noticed earlier, though, that the performance benefits were reduced
when I added a few key/value pairs so I wanted to see if that trend
continued as I added more arguments.</p>
<p>I decided to jump right to the maximum point, and create dictionaries
with 255 members. Because the number of keyword arguments passed to a
function is represented in a byte, a function may be passed at most
255 literal keyword arguments (you can pass more arguments if you
populate a dictionary and use the syntax <tt class="docutils literal"><span class="pre">callable(**kwds)</span></tt>, but 255
seemed like a reasonable number to test).</p>
<p>Not wanting to type out all of those arguments, I created one script to
generate a call to <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> with 255 arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="k">print</span> <span class="s">&#39;dict(&#39;</span><span class="p">,</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">255</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;a</span><span class="si">%d</span><span class="s">=</span><span class="si">%d</span><span class="s">,&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
<span class="k">print</span> <span class="s">&#39;)&#39;</span>
</pre></div>
</div>
<p>and another to create a literal dictionary with the same members:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="k">print</span> <span class="s">&#39;{&#39;</span><span class="p">,</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">255</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;&quot;a</span><span class="si">%r</span><span class="s">&quot;: </span><span class="si">%r</span><span class="s">,&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
<span class="k">print</span> <span class="s">&#39;}&#39;</span>
</pre></div>
</div>
<p>I then ran the scripts, and passed their output to <a class="reference external" href="http://www.doughellmann.com/PyMOTW/timeit/">timeit</a>. I
used fewer iterations, since it took longer to run each one and
process all of the arguments.</p>
<div class="highlight-python"><pre>$ python2.7 makebigfunc.py &gt; func-big.py
$ python2.7 -m timeit -n 10000 -r 5 -v "$(cat func-big.py)"
raw times: 0.214 0.211 0.211 0.216 0.221
10000 loops, best of 5: 21.1 usec per loop

$ python2.7 makebigdict.py &gt; literal-big.py
$ python2.7 -m timeit -n 10000 -r 5 -v "$(cat literal-big.py)"
raw times: 0.138 0.136 0.137 0.137 0.14
10000 loops, best of 5: 13.6 usec per loop</pre>
</div>
<p>The difference has narrowed, but using <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> still takes 1.6
times as long as <tt class="docutils literal"><span class="pre">{}</span></tt>.</p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="index.html#conclusions" title="Permalink to this headline">¶</a></h2>
<p>In summary, calling <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> requires these steps:</p>
<ol class="arabic simple">
<li>Find the object associated with the name <tt class="docutils literal"><span class="pre">&quot;dict&quot;</span></tt> and push it
onto the stack.</li>
<li>Push the key/value pairs onto the stack as constant values.</li>
<li>Get the key/value pairs off of the stack and create a dictionary
to hold the keyword arguments to the function.</li>
<li>Call the constructor for <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt> to make a new object.</li>
<li>Initialize the new object by passing the keyword arguments to its
initialization method.</li>
<li>Resize the new <tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt> and copy the key/value pairs into it
from the keyword arguments.</li>
</ol>
<p>Whereas using <tt class="docutils literal"><span class="pre">{}</span></tt> to create a dictionary uses only these steps:</p>
<ol class="arabic simple">
<li>Create an empty but pre-allocated dictionary instance.</li>
<li>Push the key/value pairs onto the stack as constant values.</li>
<li>Store each key/value pair in the dictionary.</li>
</ol>
<p>The times involved here are pretty small, but as a general principle I
try to avoid code constructions I know to introduce performance hits.
On the other hand, there may be times when using <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt> is
necessary, or easier. For example, in versions of Python earlier than
2.7, creating a dictionary from an iterable required using a generator
expression as argument to <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">)</span>
</pre></div>
</div>
<p>With 2.7 and later, though, <em>dictionary comprehensions</em> are built into
the language syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">}</span>
</pre></div>
</div>
<p>So that eliminates one common case for calling <tt class="xref py py-func docutils literal"><span class="pre">dict()</span></tt>.  Using
the literal dictionary syntax feels more &#8220;pythonic&#8221; to me, so I try to
just do it anyway.</p>
</div>
</div>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
          <li><a href="http://www.doughellmann.com/articles/index.html" >Articles</a> &raquo;</li>
          <li><a href="http://www.doughellmann.com/articles/misc/index.html" >Miscellaneous Articles</a> &raquo;</li> 
      </ul>
    </div>



<div id="addthis"><a href="http://www.addthis.com/bookmark.php" onclick="addthis_url   = location.href; addthis_title = document.title; return addthis_click(this);" target="_blank"><img src="../../../../s7.addthis.com/static/btn/lg-share-en.gif" width="125" height="16" border="0" alt="Bookmark and Share" /></a><script type="text/javascript">var addthis_pub = "dhellmann";</script><script type="text/javascript" src="../../../../s7.addthis.com/js/widget.php%3Fv=10.html"></script></div>




<!-- Disqus -->
<div id="disqus_wrapper">
<div id="disqus_thread"></div><script type="text/javascript" src="../../../../disqus.com/forums/doughellmann/embed.js"></script><noscript><a href="http://doughellmann.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>


</div>

<div id="footer">
 
<p>
    &copy; Copyright <a rel="author" href="http://www.doughellmann.com/about/index.html">2007-2011, Doug Hellmann</a>.
   | Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
   | Design based on "Leaves" by <a href="http://smallpark.org">SmallPark</a>
</p>
   
<script src="../../../../www.google-analytics.com/urchin.js" type="text/javascript" />
<script type="text/javascript">
  _uacct = "UA-1847381-1";
  urchinTracker();
</script>

</div>

</div>



<!-- Disqus -->
<script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script type="text/javascript" src="http://disqus.com/forums/doughellmann/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>



</body>
</html>